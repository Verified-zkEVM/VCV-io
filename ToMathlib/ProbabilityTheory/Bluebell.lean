import Iris
import Iris.Algebra.CMRA
import Iris.BI.BIBase
import ToMathlib.ProbabilityTheory.Coupling
import ToMathlib.ProbabilityTheory.IndepProduct
import Mathlib.Data.ENNReal.Basic
import Mathlib.Tactic
-- import Mathlib
-- import Mathlib.Tactic.EquivRW

/-! # Formalizing the Bluebell paper -/
/-
  Given a set of possible outcomes Î© (sample space),
    - An event space is a Ïƒ-algebra ğ“• âˆˆ ğ”¸(Î©), represented as `ğ“• : MeasurableSpace Î©`;
      In Bluebell terms, an event is a set of outcomes.
    - A probability distribution Î¼ : ğ“• â†’ [0, 1] âˆˆ ğ”»(ğ“•), is represented as a
      `Î¼ : Measure Î©` with the property `IsProbabilityMeasure Î¼` or a
      probability mass functions `Î¼ : PMF Î©` (see `MeasureTheory.Measure.toPMF`
      and `PMF.toMeasure`); Note: Î¼(a) abbreviates Î¼({a})
-/

/-
X âŠ‚ X'
Î¼â‚ X < Î¼â‚ X'
X âˆ© Y = X' âˆ© Y
Î¼â‚ X' * Î¼â‚‚ Y = Î¼ (X' âˆ© Y) = Î¼ (X âˆ© Y) = Î¼â‚ X * Î¼â‚‚ Y
-/

attribute [local instance] Set.monad

-- Indexed tuples
def indexedTuple (Î± : Type*) (I : Finset â„•) := I â†’ Î±

-- Question (Andrei): `(h : J âŠ† I)` not needed?
def indexedTuple.remove (Î± : Type*) (I : Finset â„•) (J : Finset â„•) /-(h : J âŠ† I)-/ :
    indexedTuple Î± I â†’ indexedTuple Î± (I \ J) :=
  fun x i => x âŸ¨i.1, by aesopâŸ©

/-- A typeclass for expressing that a type `M` has a validity predicate `âœ“` -/
class Valid (M : Type*) where
  valid : M â†’ Prop

export Valid (valid)

prefix:50(priority := high) "âœ“" => Valid.valid

instance {Î± : Type*} [Valid Î±] (p : Î± â†’ Prop) : Valid (Subtype p) where
  valid := fun x => Valid.valid x.1

instance {Î± Î² : Type*} [Valid Î±] [Valid Î²] : Valid (Î± Ã— Î²) where
  valid := fun x => Valid.valid x.1 âˆ§ Valid.valid x.2

section

open ProbabilityTheory MeasureTheory

/--
  The product of two measurable spaces on `Î©` and `Î©` is the measurable space
  generated by
-/
def MeasurableSpace.prod' {Î© : Type*}
  (mâ‚ : MeasurableSpace Î©) (mâ‚‚ : MeasurableSpace Î©) : MeasurableSpace (Î© Ã— Î©) :=
  let seed : Set (Set (Î© Ã— Î©)) := do
    let Xâ‚ : Set Î© â† MeasurableSet[mâ‚]
    let Xâ‚‚ : Set Î© â† MeasurableSet[mâ‚‚]
    return (Xâ‚.prod Xâ‚‚ : Set (Î© Ã— Î©))
  MeasurableSpace.generateFrom seed

universe u

def MeasurableSpace.prod'' {Î©â‚ Î©â‚‚ : Type u}
  (mâ‚ : MeasurableSpace Î©â‚) (mâ‚‚ : MeasurableSpace Î©â‚‚) : MeasurableSpace (Î©â‚ Ã— Î©â‚‚) :=
  let seed : Set (Set (Î©â‚ Ã— Î©â‚‚)) := do
    let Xâ‚ : Set Î©â‚ â† MeasurableSet[mâ‚]
    let Xâ‚‚ : Set Î©â‚‚ â† MeasurableSet[mâ‚‚]
    return Xâ‚.prod Xâ‚‚
  MeasurableSpace.generateFrom seed

end

notation(priority := high) mâ‚ " â¨‚ " mâ‚‚ => MeasurableSpace.prod' mâ‚ mâ‚‚

/-- The class of **discrete** cameras, which do not care about step-indexing -/
class DiscreteCMRA (Î± : Type*) extends CommSemigroup Î±, Valid Î± where
  equiv : Î± â†’ Î± â†’ Prop
  pcore : Î± â†’ Option Î±

  is_equiv : Equivalence equiv

  mul_equiv {x y z} : equiv y z â†’ equiv (x * y) (x * z)
  pcore_equiv {x y cx} : equiv x y â†’ pcore x = some cx â†’ âˆƒ cy, pcore y = some cy âˆ§ equiv cx cy

  pcore_left {x cx} : pcore x = some cx â†’ equiv (cx * x) x
  pcore_idem {x cx} : pcore x = some cx â†’ equiv x cx
  pcore_mono' {x y cx} : pcore x = some cx â†’ âˆƒ cy, pcore (x * y) = some (cx * cy)

  -- TODO: check whether these are stated correctly
  valid_equiv {x y} : equiv x y â†’ valid x â†’ valid y
  valid_mul {x y} : valid (x * y) â†’ valid x

section DiscreteCMRA

variable {Î± : Type*} [DiscreteCMRA Î±] {x yâ‚ yâ‚‚ : Î±}
open DiscreteCMRA

-- Question (Andrei): This lemma doesn't need the hypothesys `valid x`; and is not needed itself
lemma valid_extend : /- valid x â†’ -/ equiv x (yâ‚ * yâ‚‚) â†’ âˆƒ zâ‚ zâ‚‚, equiv x (zâ‚ * zâ‚‚) := by tauto

lemma valid_l_of_equiv_mul (hâ‚ : valid x) (hâ‚‚ : equiv x (yâ‚ * yâ‚‚)) : valid yâ‚ :=
                           valid_mul (valid_equiv hâ‚‚ hâ‚)

lemma valid_r_of_equiv_mul (hâ‚ : valid x) (hâ‚‚ : equiv x (yâ‚ * yâ‚‚)) : valid yâ‚‚ :=
                           valid_mul (valid_equiv (mul_comm yâ‚ yâ‚‚ â–¸ hâ‚‚) hâ‚)

-- Question (Andrei): `valid_extend` not needed here?
example : valid x â†’ equiv x (yâ‚ * yâ‚‚) â†’ âˆƒ zâ‚ zâ‚‚, equiv x (zâ‚ * zâ‚‚) âˆ§ valid zâ‚ âˆ§ valid zâ‚‚ :=
  Î» hâ‚ hâ‚‚ â†¦ âŸ¨yâ‚, yâ‚‚, hâ‚‚, valid_l_of_equiv_mul hâ‚ hâ‚‚, valid_r_of_equiv_mul hâ‚ hâ‚‚âŸ©

  -- Î» hâ‚ hâ‚‚ â†¦ let âŸ¨zâ‚, zâ‚‚, hâŸ© := valid_extend /- hâ‚ -/ hâ‚‚
  --           âŸ¨zâ‚, zâ‚‚, h, valid_l_of_equiv_mul hâ‚ h, valid_r_of_equiv_mul hâ‚ hâŸ©

end DiscreteCMRA

open Iris in
instance DiscreteCMRA.instOFE (Î± : Type*) [DiscreteCMRA Î±] : OFE Î± where
  Equiv := equiv
  Dist := fun _ â†¦ equiv
  dist_eqv := by simp [DiscreteCMRA.is_equiv]
  equiv_dist := by simp
  dist_lt := fun h _ â†¦ h

open Iris in
/-- A discrete CMRA can be converted to a regular CMRA -/
instance DiscreteCMRA.instCMRA {Î± : Type*} [DiscreteCMRA Î±] : CMRA Î± :=
  {
    pcore := pcore
    op := (Â·*Â·)
    ValidN := fun _ x â†¦ valid x
    Valid := valid
    op_ne := âŸ¨fun _ _ _ h â†¦ mul_equiv hâŸ©
    pcore_ne := pcore_equiv
    validN_ne := valid_equiv
    valid_iff_validN := by simp
    validN_succ := by simp
    assoc := by simp [mul_assoc]
    comm := by simp [mul_comm]
    pcore_op_left := pcore_left
    pcore_idem := Î» h â†¦ by obtain âŸ¨_, hâ‚, hâ‚‚âŸ© := pcore_equiv (pcore_idem h) h
                           exact hâ‚ â–¸ OFE.Equiv.symm hâ‚‚
    pcore_op_mono := fun {x cx} h y â†¦ by
      rcases @pcore_mono' Î± _ x y cx h with âŸ¨cy, hâŸ©
      use cy
      rw [h]
    validN_op_left := valid_mul
    extend {_ _ yâ‚ yâ‚‚ _ _} := by use yâ‚, yâ‚‚; simpa
  }

-- class DiscreteUnitalCMRA (Î± : Type*) extends DiscreteCMRA Î±, One Î± where

/-- Typeclass for expressing that a type `M` with multiplication and a one satisfies
`1 * a = a` on the left.

This is a unbundled version of `MulOneClass` where we don't require `a * 1 = a` on the right. -/
class MulOneLeftClass (M : Type*) extends One M, Mul M where
  /-- One is a left neutral element for multiplication -/
  protected one_mul : âˆ€ a : M, 1 * a = a

attribute [simp] MulOneLeftClass.one_mul

instance {M : Type*} [MulOneClass M] : MulOneLeftClass M where
  one_mul := one_mul

/-- An ordered unital resource algebra is a type with a multiplication, a one, a preorder `â‰¤`,
  and a validity predicate `âœ“`, such that:

  - `1` is valid
  - validity is downward closed: `a â‰¤ b â†’ âœ“ b â†’ âœ“ a`
  - validity of multiplication cancels on the right: `âœ“ (a * b) â†’ âœ“ a`
  - multiplication on the right is monotone: `a â‰¤ b â†’ a * c â‰¤ b * c` -/
class OrderedUnitalResourceAlgebra (M : Type*) extends
    MulOneLeftClass M, Valid M, Preorder M, MulRightMono M where
  valid_one : âœ“ (1 : M)
  valid_mono {a b} : a â‰¤ b â†’ âœ“ b â†’ âœ“ (a : M)
  valid_mul {a b} : âœ“ (a * b : M) â†’ âœ“ a

export OrderedUnitalResourceAlgebra (valid_one valid_mono valid_mul)

attribute [simp] valid_one

namespace OrderedUnitalResourceAlgebra

variable {I M : Type*} [OrderedUnitalResourceAlgebra M]

instance : MulRightMono M := âŸ¨fun _ _ _ h â†¦ mul_left_mono hâŸ©

/-- Lifting the validity predicate to indexed tuples by requiring all elements to be valid -/
@[simp]
instance [Valid M] : Valid (I â†’ M) where
  valid := fun x => âˆ€ i, âœ“ x i

/-- A resource algebra on `M` is lifted pointwise to a resource algebra on `I â†’ M` -/
instance {I : Type*} : OrderedUnitalResourceAlgebra (I â†’ M) where
  one_mul := by intro a; funext i; simp only [Pi.mul_apply, Pi.one_apply, MulOneLeftClass.one_mul]
  valid_one := by intro i; exact valid_one
  valid_mono := by intro _ _ hab hb i; exact valid_mono (hab i) (hb i)
  valid_mul := by intro _ _ hab i; exact valid_mul (hab i)
  elim := by intro _ _ _ h; exact fun i => mul_left_mono (h i)

/-- Define a discrete `CMRA` instance given an `OrderedUnitalResourceAlgebra` instance -/
instance instCMRA [Valid M] : DiscreteCMRA M := sorry

end OrderedUnitalResourceAlgebra


/-! ## Permissions -/

/-- A permission on type `Î±` is a map from `Î±` to the non-negative rationals `â„šâ‰¥0`.

We need to have the `Multiplicative` tag in order to specify that multiplication is pointwise
addition, and unit is the constant zero map. -/
@[reducible] def Permission (Î± : Type*) := Multiplicative (Î± â†’ â„šâ‰¥0)

variable {Î± Î² : Type*}

-- instance : Preorder (Permission Î±) := inferInstanceAs (Preorder (Multiplicative (Î± â†’ â„šâ‰¥0)))
-- instance : MulOneClass (Permission Î±) := inferInstanceAs (MulOneClass (Multiplicative (Î± â†’ â„šâ‰¥0)))
-- instance : MulLeftMono (Permission Î±) := inferInstanceAs (MulLeftMono (Multiplicative (Î± â†’ â„šâ‰¥0)))

/-- Permissions form an `OrderedUnitalResourceAlgebra` where `â‰¤` is defined pointwise,
  a resource is valid iff it's below `1` pointwise, and composition is pointwise multiplication -/
instance : OrderedUnitalResourceAlgebra (Permission Î±) where
  valid := fun p => p â‰¤ 1
  valid_one := by simp
  valid_mul := by
    intro a b hab
    simp_all only [le_one_iff_eq_one, mul_eq_one, le_refl]
  valid_mono := by intro a b h h'; simp_all only [le_one_iff_eq_one]
  -- mul_right_mono := by intro a b c h i; sorry

/-! ## Probability spaces -/

variable {Î© : Type*}

noncomputable section

-- Tried without success:

-- abbrev Measure' {Î± : Type} (ms : MeasurableSpace Î±) := @Measure Î± ms

-- def Measure' (Î© : Type*) := (ms : MeasurableSpace Î©) â†’ @Measure Î© ms

section

open ProbabilityTheory MeasureTheory Function

universe u

variable {Î© : Type u}
         {msâ‚ msâ‚‚ : MeasurableSpace Î©}
         {Î¼â‚ : Measure[msâ‚] Î©} {Î¼â‚‚ : Measure[msâ‚‚] Î©}

namespace MeasureTheory

structure Measure.IndependentProduct
  (Î¼â‚ : Measure[msâ‚] Î©) (Î¼â‚‚ : Measure[msâ‚‚] Î©) : Type u where
  Î¼ : Measure[MeasurableSpace.sum msâ‚ msâ‚‚] Î©
  inter_eq_prod {X Y} (hX : MeasurableSet[msâ‚] X) (hY : MeasurableSet[msâ‚‚] Y) :
    Î¼ (X âˆ© Y) = Î¼â‚ X * Î¼â‚‚ Y

@[simp]
lemma Measure.nonempty_IndependentProduct_of_nonempty [Nonempty Î©] :
  Nonempty (Î¼â‚.IndependentProduct Î¼â‚‚) := sorry

def MeasurableSpace.independentProduct (msâ‚ msâ‚‚ : MeasurableSpace Î©) : MeasurableSpace Î© :=
  MeasurableSpace.generateFrom (MeasurableSet[msâ‚] âˆª MeasurableSet[msâ‚‚])

end MeasureTheory

structure MeasureOnSpace (Î© : Type u) where
  ms : MeasurableSpace Î©
  Î¼ : Measure[ms] Î©

def MeasureOnSpace.isPSpace (mos : MeasureOnSpace Î©) := IsProbabilityMeasure mos.Î¼

instance : Decidable (Nonempty (Î¼â‚.IndependentProduct Î¼â‚‚)) := Classical.propDecidable _

def MeasureTheory.Measure.independentProduct
  (Î¼â‚ : Measure[msâ‚] Î©) (Î¼â‚‚ : Measure[msâ‚‚] Î©) : Option (MeasureOnSpace Î©) :=
  if h : Nonempty (Î¼â‚.IndependentProduct Î¼â‚‚)
  then .some âŸ¨msâ‚.independentProduct msâ‚‚, h.some.Î¼âŸ©
  else .none

def MeasureOnSpace.independentProduct {Î© : Type u}
  (msâ‚ msâ‚‚ : MeasureOnSpace Î©) : Option (MeasureOnSpace Î©) := msâ‚.Î¼.independentProduct msâ‚‚.Î¼

def PSpace (Î© : Type u) := {mos : MeasureOnSpace Î© // mos.isPSpace}

@[simp]
lemma PSpace.isPMeasure_measure {Î© : Type u} {ps : PSpace Î©} : IsProbabilityMeasure ps.1.Î¼ := ps.2

lemma isPMeasure_iProd_of_isPMesure_nonempty
  {mosâ‚ mosâ‚‚ : MeasureOnSpace Î©}
  (hâ‚ : IsProbabilityMeasure mosâ‚.Î¼) (hâ‚‚ : IsProbabilityMeasure mosâ‚‚.Î¼) :
  (mosâ‚.independentProduct mosâ‚‚).elim True MeasureOnSpace.isPSpace := sorry

def PSpace.independentProduct (psâ‚ psâ‚‚ : PSpace Î©) : Option (PSpace Î©) :=
  (psâ‚.1.independentProduct psâ‚‚.1).attach.map fun âŸ¨mos, hmosâŸ© â†¦ by
  have := hmos â–¸ isPMeasure_iProd_of_isPMesure_nonempty (by simp) (by simp)
  exact âŸ¨mos, thisâŸ©

end

instance [ne : Nonempty Î©] : One (PSpace Î©) where
  one := haveI : MeasurableSpace Î© := âŠ¥
         letI measure := MeasureTheory.Measure.dirac ne.some
         âŸ¨âŸ¨this, measureâŸ©, MeasureTheory.Measure.dirac.isProbabilityMeasureâŸ©

section Wheels

namespace MeasureTheory

@[simp]
abbrev Measure.map! (msâ‚ : MeasurableSpace Î±) (msâ‚‚ : MeasurableSpace Î²)
                    (f : Î± â†’ Î²) (Î¼ : Measure Î±) : Measure Î² := @Î¼.map _ _ msâ‚ msâ‚‚ f

@[simp]
abbrev Measure.cast {Î² : Type u} {msâ‚ : MeasurableSpace Î²}
  (Î¼ : Measure Î²) (msâ‚‚ : MeasurableSpace Î²) := Î¼.map! msâ‚ msâ‚‚ id

scoped notation "Measure[" mÎ± "] " Î±:arg => @Measure Î± mÎ±

end MeasureTheory

end Wheels

instance (Î© : Type*) : Preorder (PSpace Î©) where
  le (psâ‚ psâ‚‚) := (psâ‚.1.ms â‰¤ psâ‚‚.1.ms) âˆ§ psâ‚.1.Î¼ = psâ‚‚.1.Î¼.cast _
  le_refl := by simp
  le_trans {a b c} (hâ‚ hâ‚‚) := by
    aesop (add safe forward le_trans) (add safe (by rw [MeasureTheory.Measure.map_map]))

abbrev PSp (Î© : Type u) := WithTop (PSpace Î©)

instance : Valid (PSp Î©) where
  valid {ms?} := ms?.isSome

instance : Mul (PSp Î©) where
  mul {x y} := 
  match x, y with
  | .some x, .some y => x.independentProduct y
  | .none, .some _ | .some _, .none | .none, .none => .none

open MeasureTheory MeasurableSpace in
instance [ne : Nonempty Î©] : OrderedUnitalResourceAlgebra (PSp Î©) where
  one_mul (p) := by
    unfold_projs
    rcases p with _ | âŸ¨âŸ¨ms, Î¼âŸ©, hpâŸ©
    Â· simp
    Â· simp only [
        PSpace.independentProduct,
        MeasureOnSpace.independentProduct,
        MeasureTheory.Measure.independentProduct
      ]
      rw! [dif_pos (by simp)]
      simp only [Option.attach_some, Option.map_some]
      rw [Option.some_inj]
      generalize_proofs _ _ _ _ bot ne
      rcases ne with âŸ¨hâ‚, hâ‚‚âŸ©
      congr
      Â· ext elem
        unfold independentProduct MeasurableSet MeasurableSet' -- Ugly.
        rw [â†MeasurableSpace.generateFrom_sup_generateFrom, sup_of_le_right sorry]
        sorry
      Â· sorry 
  valid := valid
  elim := sorry
  valid_one := rfl
  valid_mono := by sorry
  valid_mul := by intro a b hab; cases a <;> cases b <;> sorry

-- open ENNReal in
-- def PMF.prod {Î©â‚ Î©â‚‚ : Type u}
--   (Î¼ : PMF Î©â‚)
--   (Î½ : PMF Î©â‚‚) :
--   PMF (Î©â‚ Ã— Î©â‚‚)
-- :=
--   -- let Î¼' (x : Î©â‚ Ã— Î©â‚‚) : â„â‰¥0âˆ := Î¼ x.1
--   -- let Î½' (x : Î©â‚ Ã— Î©â‚‚) : â„â‰¥0âˆ := Î½ x.2
--   âŸ¨ Î» a â†¦ Î¼ a.1 * Î½ a.2
--   , by
--       let hâ‚ := Î¼.2
--       -- let Î¼' (x : Î©â‚ Ã— Î©â‚‚) : â„â‰¥0âˆ := Î¼ x.1
--       -- let Î½' (x : Î©â‚ Ã— Î©â‚‚) : â„â‰¥0âˆ := Î½ x.2
--       -- have hâ‚ : HasSum Î¼' 1 := by sorry
--       have _ : IsTopologicalSemiring â„â‰¥0âˆ := sorry
--       rw [â†(one_mul 1)]
--       apply HasSum.mul (f := Î¼) (g := Î½) (s := 1) (t := 1)
--       apply Î¼.2
--       apply Î½.2
--       sorry
--   âŸ©

section

open ProbabilityTheory MeasureTheory

lemma ProbabilitySpace.event_space_nonepmty {Î© : Type*} [instMeasurable : MeasurableSpace Î©]
  (volume : Measure Î©)
  (is_prob : IsProbabilityMeasure volume) :
  Nonempty Î©
:= Exists.nonempty (nonempty_of_measure_ne_zero (show volume.measureOf Set.univ â‰  0 by aesop))

-- lemma one_prod_one {Î©â‚ Î©â‚‚} [Nonempty Î©â‚] [Nonempty Î©â‚‚] :
--   (1 : ProbabilitySpace Î©â‚).prod (1 : ProbabilitySpace Î©â‚‚) = (1 : ProbabilitySpace (Î©â‚ Ã— Î©â‚‚))
-- := by
--   -- generalize_proofs
--   have _ : ProbabilitySpace Î©â‚ := (1 : ProbabilitySpace Î©â‚)
--   have _ : ProbabilitySpace Î©â‚‚ := (1 : ProbabilitySpace Î©â‚‚)
--     -- @ProbabilitySpace.mk Î©â‚ ((1 : ProbabilitySpace Î©â‚).toMeasureSpace) sorry
--   unfold ProbabilitySpace.prod volume
--   simp
--   unfold_projs
--   congr 1
--   -- simp [Measure.dirac]

--   unfold Measure.prod.measureSpace
--   -- let bot : MeasurableSpace (Î©â‚ Ã— Î©â‚‚) := âŠ¥
--   -- apply MeasurableSpace.ext (Î± := (Î©â‚ Ã— Î©â‚‚))
--   -- ext
--   unfold volume
--   simp only
--   rw [Measure.prod_eq]

--   congr 1
--   Â· simp [Prod.instMeasurableSpace]
--     ext s
--     -- unfold_projs
--     unfold MeasurableSet MeasurableSpace.prod
--     simp
--   Â·
--     rw [heq_iff_eq (Î± := Measure (Î©â‚ Ã— Î©â‚‚))]
--     unfold volume
--     -- apply heq_of_eq
--     -- simp [heq_iff_eq, Measure.prod_prod]
--     -- apply heq_iff_eq.2
--     -- rw [heq_iff_eq]
--     -- ext
--     -- simp
--     -- simp [Measure.prod_prod]


variable {V : Type*}

def MeasureSpace.map {Î©â‚ Î©â‚‚ : Type*} (f : Î©â‚ â†’ Î©â‚‚) (m : MeasureSpace Î©â‚) :
  MeasureSpace Î©â‚‚
:=
  let _ : MeasurableSpace Î©â‚‚ := m.toMeasurableSpace.map f
  let v : Measure Î©â‚‚ := m.volume.map f
  .mk v

-- def ProbabilitySpace.map {Î©â‚ Î©â‚‚ : Type*} (f : Î©â‚ â‰ƒ Î©â‚‚) (ps : ProbabilitySpace Î©â‚) :
--   ProbabilitySpace Î©â‚‚
-- :=
--   let measureSâ‚‚ : MeasureSpace Î©â‚‚ := MeasureSpace.map f ps.toMeasureSpace
--   let _ : IsProbabilityMeasure measureSâ‚‚.volume := by
--     suffices (Measure.map â‡‘f â„™) Set.univ = 1 by constructor; simpa
--     rw [Measure.map_apply (show Measurable â‡‘f from fun _ â†¦ (Â·)) (by simp)]
--     simp [ps.is_prob.1]
--   .mk

def store_prod_equiv {Î± V : Type*} (p : Permission Î±) :
  ({ a // p a > 0 } â†’ V) Ã— ({ a // p a = 0 } â†’ V) â‰ƒ (Î± â†’ V)
:=
  {
    toFun f x := if h : p x > 0 then f.1 âŸ¨x, hâŸ© else f.2 âŸ¨x, by simpa using hâŸ©,
    invFun f := âŸ¨(f Â·), (f Â·)âŸ©,
    left_inv := by
      simp only [Function.LeftInverse, gt_iff_lt, Subtype.coe_eta, Prod.forall, Prod.mk.injEq]
      intros fâ‚ fâ‚‚
      constructor <;> ext x <;> simp [x.2],
    right_inv := by
      simp only [Function.RightInverse, Function.LeftInverse, gt_iff_lt, dite_eq_ite, ite_self,
        implies_true]
  }

open Classical in
-- Needs to encode the term `P = P' âŠ— ğŸ™_ (p.support â†’ V)` in the paper
/-- Compatibility of a probability space with a permission, defined as the existence of a splitting between:

- the trivial probability space on the zero part of the permission `ğŸ™_ ({a // p a = 0} â†’ V)`
- another probability space `P'` on the non-zero part of the permission -/
-- We need product and union spaces
def MeasureOnSpace.compatiblePerm
  (M : MeasureOnSpace (Î± â†’ V))
  -- (is_prob : IsProbabilityMeasure M)
  (p : Permission Î±) :
  Prop
:= âˆ€ _ : Nonempty ({a // p a = 0} â†’ V),
  let one : MeasureOnSpace ({ a // p a = 0 } â†’ V) := One.one
  let _ := one.measurableSpace
  âˆƒ (M' : MeasureOnSpace ({a // p a > 0} â†’ V)),
      let _ : MeasurableSpace ({ a // p a > 0 } â†’ V) := M'.measurableSpace
      -- let spaceProduct : MeasurableSpace (({a // p a > 0} â†’ V) Ã— ({a // p a = 0} â†’ V)) :=
      --   Î¼_space.prod one_space
      let measureProduct : MeasureOnSpace (({ a // p a > 0 } â†’ V) Ã— ({ a // p a = 0 } â†’ V)) :=
        M'.toMeasure.prod one.toMeasure |> ofMeasure
      let M' : MeasureOnSpace (({ a // p a > 0 } â†’ V) Ã— ({ a // p a = 0 } â†’ V)) :=
        M.map (store_prod_equiv p).2
      -- spaceProduct.MeasurableSet' = Set.image (Set.image (store_prod_equiv p).2) M.measurableSpace.MeasurableSet'
      measureProduct = M'

/-- Generalize compatibility of `ProbabilitySpace` with `Permission` to `PSp` by letting `âŠ¤` be
  compatible with all permission maps -/
def PSp.compatiblePerm (P : PSp (Î± â†’ V)) (p : Permission Î±) : Prop := match P with
  | some P => P.compatiblePerm p
  | none => True

/-- The joint structure of a probability space and a permission that are compatible.

This is given a resource algebra structure by pointwise product of the underlying probability space
and permission RAs, up to compatibility. -/
@[reducible]
def PSpPm (Î± : Type*) (V : Type*) :=
  {p : PSp (Î± â†’ V) Ã— Permission Î± // p.1.compatiblePerm p.2}

end

namespace PSpPm

/-- Lift a probability space to a probability space-permission pair, via coupling it with the
  all-one permission -/
-- TODO (Andrei): In the Bluebell paper, Î¼ is used for distribution, while ğ“Ÿ is used for probability spaces
def liftProb (volume : MeasureOnSpace (Î± â†’ V)) : PSpPm Î± V :=
  âŸ¨âŸ¨volume, 1âŸ©, by sorryâŸ©

@[simp]
instance [Nonempty V] : One (PSpPm Î± V) where
  one :=
    { val := âŸ¨One.one, fun _ â†¦ 0âŸ©
      property := by
        simp
        intro
        use 1
        simp
        unfold_projs
        simp only [MeasureTheory.Measure.prod_prod]
        sorry
    }

/-- Multiplication is pointwise product of the probability space and the permission -/
@[simp]
instance [Nonempty V] : Mul (PSpPm Î± V) where
  -- TODO: need to prove product preserves compatibility
  mul Ppâ‚ Ppâ‚‚ := âŸ¨âŸ¨Ppâ‚.1.1 * Ppâ‚‚.1.1, Ppâ‚.1.2 * Ppâ‚‚.1.2âŸ©, by simp only; sorryâŸ©

-- TODO (Andrei): We need validity defined
-- instance : Valid (PSpPm Î± V) := inferInstanceAs <|
--   Valid (Subtype (fun Pp : PSp (Î± â†’ V) Ã— Permission Î± => Pp.1.compatiblePerm Pp.2))

/-- The resource algebra instance on `PSpPm Î± V` -/
instance [Nonempty V] : OrderedUnitalResourceAlgebra (PSpPm Î± V) where
  one_mul := by
    unfold_projs
    dsimp
    simp; intro P p h; sorry
  valid_one := by simp [Valid.valid, One.one]; sorry
  valid_mul := by sorry
  valid_mono := by sorry
  elim := by sorry

end PSpPm

end

/-- The main model of Bluebell is a function type `I â†’ PSpPm Î± V`, where `I` is
  the index set of (independent) program executions. The resource algebra structure
  is lifted pointwise from `PSpPm`.

To handle multiple programs drawn from index set `I`, we use the RA `I â†’ PSpPm` where
operations are lifted pointwise -/
abbrev IndexedPSpPm (I Î± V : Type*) := I â†’ PSpPm Î± V

namespace IndexedPSpPm

variable {I Î± V : Type*}

/-- Lift an indexed set of probability spaces to an indexed set of probability space-permission
  pairs, via pointwise lifting -/
def liftProb (Î¼ : I â†’ MeasureOnSpace (Î± â†’ V)) : IndexedPSpPm I Î± V :=
  fun i => PSpPm.liftProb (Î¼ i)

instance : FunLike (IndexedPSpPm I Î± V) I (PSpPm Î± V) where
  coe := fun x => x
  coe_injective' := by intro x y h; simp [h]

noncomputable instance [Nonempty V] : OrderedUnitalResourceAlgebra (IndexedPSpPm I Î± V) :=
  inferInstanceAs (OrderedUnitalResourceAlgebra (I â†’ PSpPm Î± V))

end IndexedPSpPm

/-- A hyper-assertion is an upward closed predicate on `IndexedPSpPm I Î± V`.

We re-use the existing Lean structure `UpperSet`, so an element of this type has:

-- A * B â†’ A

- a carrier (a `Set`, equivalent to a predicate)
- a proof that the set is upward closed -/
abbrev HyperAssertion (I Î± V : Type*) := UpperSet (IndexedPSpPm I Î± V)
  -- {ha : IndexedPSpPm I Î± V â†’ Prop // âˆ€ x y, x â‰¤ y â†’ ha x â†’ ha y}

/-- `FunLike` instance for `HyperAssertion` so that we can write `P a` instead of `a âˆˆ P` -/
instance {I Î± V : Type*} : FunLike (HyperAssertion I Î± V) (IndexedPSpPm I Î± V) Prop where
  coe := fun P => P.carrier
  coe_injective' := by intro P Q h; aesop

namespace HyperAssertion

variable {I Î± V : Type*}

/-- The predicate underlying a hyper-assertion -/
def pred (P : HyperAssertion I Î± V) : IndexedPSpPm I Î± V â†’ Prop := (Â· âˆˆ P.carrier)

/-- A hyper-assertion `P` is irrelevant for a finite set of indices `J` if it is entailed by the set
  of all probability spaces that are compatible with the permission at each index.

  Note that there may be multiple such `J`. -/
def isIrrelevant [DecidableEq I] [Fintype I] (J : Set I) (P : HyperAssertion I Î± V) : Prop :=
  âˆ€ a, (âˆƒ a' : IndexedPSpPm I Î± V, valid a' âˆ§ (âˆ€ i âˆ‰ J, a i = a' i) âˆ§ P a') â†’ P a

/-- The relevant indices `idx(P)` of a hyper-assertion `P` is the smallest subset of `I` whose
  complement is irrelevant for `P`. -/
def relevantIndices [DecidableEq I] [Fintype I] (P : HyperAssertion I Î± V) : Set I :=
  sInf (setOf (fun J : Set I => isIrrelevant J.compl P))

/-- The empty hyper-assertion -/
def emp : HyperAssertion I Î± V := âŸ¨setOf (fun _ => False), fun _ _ _ h => hâŸ©

/-- The entailment relation on hyper-assertions:
  `P âŠ¢ Q` if for any valid resource `a`, if `P` holds for `a`, then `Q` holds for `a`. -/
def entails (P Q : HyperAssertion I Î± V) : Prop :=
  âˆ€ a, âœ“ a â†’ P a â†’ Q a

/-- Equivalence between hyper-assertions is defined as mutual entailment, denoted `P âŠ£âŠ¢ Q` -/
def equiv (P Q : HyperAssertion I Î± V) : Prop :=
  entails P Q âˆ§ entails Q P

/-- Lift a proposition to a hyper-assertion, `âŒœ Ï† âŒ` -/
def pure (Ï† : Prop) : HyperAssertion I Î± V := âŸ¨setOf (fun _ => Ï†), fun _ _ _ ha => haâŸ©

alias lift := pure

/-- Conjunction of two hyper-assertions, defined pointwise -/
def and (P Q : HyperAssertion I Î± V) : HyperAssertion I Î± V :=
  âŸ¨setOf (fun a => P a âˆ§ Q a), fun _ _ hab âŸ¨hP, hQâŸ© => âŸ¨P.upper' hab hP, Q.upper' hab hQâŸ©âŸ©

/-- Disjunction of two hyper-assertions, defined pointwise -/
def or (P Q : HyperAssertion I Î± V) : HyperAssertion I Î± V :=
  âŸ¨setOf (fun a => P a âˆ¨ Q a), fun _ _ hab h => match h with
    | Or.inl hP => Or.inl (P.upper' hab hP)
    | Or.inr hQ => Or.inr (Q.upper' hab hQ)âŸ©

-- Note: don't think we can define implication `â†’` or negation `Â¬`, since upward closedness gives the
-- wrong direction

-- Not sure how to define these either
def sForall (Î¨ : HyperAssertion I Î± V â†’ Prop) : HyperAssertion I Î± V :=
  âŸ¨
    fun Ïƒ â†¦ âˆ€ p, Î¨ p â†’ p Ïƒ,
    by
      intros a b h
      rw [Set.mem_def, Set.mem_def]
      intros Ï† p h'
      have := p.2
      specialize Ï† p h'
      unfold IsUpperSet at this
      simp_all only [UpperSet.carrier_eq_coe, SetLike.mem_coe]
      apply this
      on_goal 2 => {exact Ï†}
      Â· simp_all only
  âŸ©

def sExists (Î¨ : HyperAssertion I Î± V â†’ Prop) : HyperAssertion I Î± V :=
  âŸ¨
    fun Ïƒ â†¦ âˆƒ p, Î¨ p âˆ§ p Ïƒ,
    by
      intros a b h
      rw [Set.mem_def, Set.mem_def]
      rintro âŸ¨p, hÎ¨, hpâŸ©
      use p
      apply And.intro hÎ¨
      have := p.2
      unfold IsUpperSet at this
      simp_all only [UpperSet.carrier_eq_coe, SetLike.mem_coe]
      apply this
      on_goal 2 => {exact hp
      }
      Â· simp_all only
  âŸ©

/-- Existential quantification over hyper-assertions -/
def Â«existsÂ» {Î² : Sort*} (P : Î² â†’ HyperAssertion I Î± V) : HyperAssertion I Î± V :=
  âŸ¨setOf (fun a => âˆƒ b, P b a), fun _ _ hab âŸ¨b, hâŸ© => âŸ¨b, (P b).upper' hab hâŸ©âŸ©

/-- Universal quantification over hyper-assertions -/
def Â«forallÂ» {Î² : Sort*} (P : Î² â†’ HyperAssertion I Î± V) : HyperAssertion I Î± V :=
  âŸ¨setOf (fun a => âˆ€ b, P b a), fun _ _ hab h b => (P b).upper' hab (h b)âŸ©

/-- Separating conjunction of two hyper-assertions, `P âˆ— Q`, defined for every `a` as the existence of elements
  `bâ‚ âˆˆ P` and `bâ‚‚ âˆˆ Q` respectively, such that `bâ‚ * bâ‚‚ â‰¤ a`. -/
def sep (P : HyperAssertion I Î± V) (Q : HyperAssertion I Î± V) : HyperAssertion I Î± V :=
  âŸ¨
    setOf (fun a => âˆƒ aâ‚€ aâ‚ : IndexedPSpPm I Î± V, a = aâ‚€ * aâ‚ âˆ§ P aâ‚€ âˆ§ Q aâ‚),
    by
      intros a b a_b_ord
      simp only [Set.mem_setOf]
      rintro âŸ¨aâ‚€, aâ‚, hâŸ©
      have : âˆƒ c, b = a * c := by
        unfold LE.le Pi.hasLe
          at a_b_ord
        dsimp only [LE.le] at a_b_ord
        have c : IndexedPSpPm I Î± V := by
          intro i
          specialize a_b_ord i
          sorry
        unfold_projs
        sorry
      rcases this with âŸ¨c, h'âŸ©
      rw [h.1] at h'
      use aâ‚€
      use (aâ‚ * c)
      rw [h']
      apply And.intro
      Â· exact mul_assoc aâ‚€ aâ‚ c
      Â· apply And.intro
        Â· exact h.2.1
        Â· have := Q.2
          unfold IsUpperSet at this
          specialize @this aâ‚ (aâ‚ * c) sorry h.2.2
          exact this
  âŸ©
  -- âŸ¨setOf (fun a => âˆ€ b, valid (a * b) â†’ P b â†’ Q (a * b)), fun a a' ha h b hbâ‚ hbâ‚‚ => by
  --   simp_all; sorryâŸ©

/-- Separating implication of two hyper-assertions, `P -âˆ— Q`, defined for every `a` as the existence of elements
  `bâ‚ âˆˆ P` and `bâ‚‚ âˆˆ Q` respectively, such that `bâ‚ * bâ‚‚ â‰¤ a`. -/
def wand (P : HyperAssertion I Î± V) (Q : HyperAssertion I Î± V) : HyperAssertion I Î± V :=
  âŸ¨setOf (fun a => âˆƒ bâ‚ bâ‚‚, (bâ‚ * bâ‚‚) â‰¤ a âˆ§ bâ‚ âˆˆ P âˆ§ bâ‚‚ âˆˆ Q),
    fun _ _ hab âŸ¨bâ‚, bâ‚‚, h, hbâ‚, hbâ‚‚âŸ© => âŸ¨bâ‚, bâ‚‚, le_trans h hab, hbâ‚, hbâ‚‚âŸ©âŸ©

open Iris.BI in
instance : BIBase (HyperAssertion I Î± V) where
  Entails := entails
  emp := emp
  pure := pure
  and := and
  or := or
  imp P Q := âŸ¨fun y â†¦ (âˆ€ x, y â‰¤ x â†’ P x â†’ Q x), by sorryâŸ©
  sForall := sForall
  sExists := sExists
  sep := sep
  wand := wand
  persistently := id
  later := id

section Ownership

/-! ### Ownership-related hyper-assertions -/

/-- Ownership of a resource `b : IndexedPSpPm I Î± V`, defined for every `a` as the predicate `b â‰¤ a`. -/
def own (b : IndexedPSpPm I Î± V) : HyperAssertion I Î± V :=
  âŸ¨setOf (fun a => b â‰¤ a), fun _ _ hab ha => le_trans ha habâŸ©

/-- Ownership of an indexed tuple of probability spaces `P : I â†’ PSp (Î± â†’ V)` and permissions
  `p : I â†’ Permission Î±`, defined as the existence of compatibility proofs `h` for each element, such
  that we have ownership of the overall tuple (with the compatibility proof). -/
def ownIndexedTuple (P : I â†’ MeasureOnSpace (Î± â†’ V)) (p : I â†’ Permission Î±) : HyperAssertion I Î± V :=
  Â«existsÂ» (fun h : âˆ€ i, (P i).compatiblePerm (p i) => own (fun i => âŸ¨âŸ¨P i, p iâŸ©, h iâŸ©))

variable [DecidableEq I] [Nonempty V] {Î² : Type*} [MeasurableSpace Î²]

/-- Ownership of an indexed probability spaces `P : I â†’ PSp (Î± â†’ V)`, defined as the
  existence of a compatible indexed permission `p : I â†’ Permission Î±` such that we have
  ownership of the overall tuple. -/
def ownIndexedProb (P : I â†’ MeasureOnSpace (Î± â†’ V)) : HyperAssertion I Î± V :=
  Â«existsÂ» (fun p : I â†’ Permission Î± => ownIndexedTuple P p)

/-- The hyper-assertion `EâŸ¨iâŸ© âˆ¼ Î¼`, for some expression `E : (Î± â†’ V) â†’ Î²`, index `i : I`,
  and discrete probability distribution `Î¼ : PMF Î²`, is defined as
  `âˆƒ P, Own P âˆ— lift ((EâŸ¨iâŸ© is a.e. measurable for (P i)) âˆ§ Î¼ = (P i).Î¼.map E)`-/
def assertSampledFrom (i : I) (E : (Î± â†’ V) â†’ Î²) (Î¼ : PMF Î²) : HyperAssertion I Î± V :=
  Â«existsÂ» (fun P : I â†’ MeasureOnSpace (Î± â†’ V) =>
    sep (ownIndexedProb P)
      (lift (@AEMeasurable _ _ _ (P i).ÏƒAlg E (P i).Î¼ âˆ§ Î¼.toMeasure = @MeasureTheory.Measure.map _ _ (P i).ÏƒAlg _ E (P i).Î¼)))

/-- Assertion that the expected value of `E` at index `i` is `ev` -/
def assertExpectation [TopologicalSpace Î²] [AddCommMonoid Î²] [SMul ENNReal Î²]
    (i : I) (E : (Î± â†’ V) â†’ Î²) (ev : Î²) : HyperAssertion I Î± V :=
  Â«existsÂ» (fun Î¼ => sep (assertSampledFrom i E Î¼) (lift (ev = âˆ‘' b, (Î¼ b) â€¢ b)))

/-- Assertion that the probability of a Boolean-valued expression `E` at index `i` is `prob` -/
def assertProbability (i : I) (E : (Î± â†’ V) â†’ Bool) (prob : ENNReal) : HyperAssertion I Î± V :=
  Â«existsÂ» (fun Î¼ => sep (assertSampledFrom i E Î¼) (lift (prob = Î¼ true)))

/-- Assertion that `E` is true almost surely -/
noncomputable def assertTrue (i : I) (E : (Î± â†’ V) â†’ Bool) : HyperAssertion I Î± V :=
  assertSampledFrom i E (PMF.pure true)

/-- Assertion that we own `E` (but its distribution is not known) -/
def assertOwn (i : I) (E : (Î± â†’ V) â†’ Î²) : HyperAssertion I Î± V :=
  Â«existsÂ» (fun Î¼ => assertSampledFrom i E Î¼)

/-- Assertion that the variable `x : Î±` at index `i` has permission `q : â„šâ‰¥0` -/
def assertPermissionVar (i : I) (x : Î±) (q : â„šâ‰¥0) : HyperAssertion I Î± V :=
  Â«existsÂ» (fun Pp : IndexedPSpPm I Î± V => sep (own Pp) (lift ((Pp i).1.2 x = q)))

/-- Assertion that a hyper-assertion `P` holds alongside an ownership of an indexed permission `p`

This is useful when defining pre-conditions at the beginning of the program (where we have a
precondition `P` and all variables have permission `1`) -/
def assertPermission (P : HyperAssertion I Î± V) (p : I â†’ Permission Î±) : HyperAssertion I Î± V :=
  and P <|
    Â«existsÂ» (fun compatP : {P : I â†’ MeasureOnSpace (Î± â†’ V) // âˆ€ i, (P i).compatiblePerm (p i)} =>
      own (fun i => âŸ¨âŸ¨compatP.1 i, p iâŸ©, compatP.2 iâŸ©))

end Ownership

def isPermissionAbstract (X : Set (I Ã— Î±)) (P : HyperAssertion I Î± V) : Prop := sorry
  -- âˆ€ Pp : IndexedPSpPm I Î± V, âˆ€ q : â„šâ‰¥0, âˆ€ n : â„•+, P Pp â‰¤ P â†’ âˆƒ Pp' : IndexedPSpPm I Î± V, Pp' â‰¤ P âˆ§ Pp = Pp' âˆ§ True

/-- The joint conditioning modality -/

def jointCondition {A : Type*} /- [MeasurableSpace V] -/
  (Î¼ : PMF A)
  (K : A â†’ HyperAssertion I Î± V) :
  HyperAssertion I Î± V
:=
  -- TODO (Andrei): define Perm â‰œ I â†’ Permission Î±
  { carrier a :=
      âˆƒ (ğ“•_ : I â†’ MeasurableSpace (Î± â†’ V))
        (Î¼_ : I â†’ PMF (Î± â†’ V))
        (p_ : I â†’ Permission Î±)
        (k_ : I â†’ A â†’ PMF (Î± â†’ V))
        (h :
          âˆ€ i,
            let _ : MeasurableSpace (Î± â†’ V) := ğ“•_ i;
            let psâ‚ : PSp (Î± â†’ V) := some (MeasureOnSpace.ofPMF (Î¼_ i));
            PSp.compatiblePerm (psâ‚, p_ i).1 (psâ‚, p_ i).2
        )
        (h' :
          âˆ€ Ï… i,
            let _ : MeasurableSpace (Î± â†’ V) := ğ“•_ i;
            let psâ‚‚ : PSp (Î± â†’ V) := some (MeasureOnSpace.ofPMF (k_ i Ï…));
            PSp.compatiblePerm (psâ‚‚, p_ i).1 (psâ‚‚, p_ i).2
        ),
        -- (ğ“•_, Î¼_, p_)
        let Pâ‚ : IndexedPSpPm I Î± V := Î» i â†¦
          let _ : MeasurableSpace (Î± â†’ V) := ğ“•_ i
          let psâ‚ : PSp (Î± â†’ V) := some (MeasureOnSpace.ofPMF (Î¼_ i))
          {val := (psâ‚, p_ i), property := h i}
        -- (ğ“•_, k_ (I)(Ï…), p_)
        let Pâ‚‚ Ï… : IndexedPSpPm I Î± V := Î» i â†¦
          let _ : MeasurableSpace (Î± â†’ V) := ğ“•_ i
          let psâ‚‚ : PSp (Î± â†’ V) := some (MeasureOnSpace.ofPMF (k_ i Ï…))
          {val := (psâ‚‚, p_ i), property := h' Ï… i}
        Pâ‚ â‰¤ a âˆ§ âˆ€ i : I, Î¼_ i = Î¼.bind (k_ i) âˆ§ âˆ€ Ï… âˆˆ Î¼.support, K Ï… (Pâ‚‚ Ï…)
  , upper' := Î» a b ord â†¦ by
      rintro âŸ¨ğ“•_, Î¼_, p_, k_, h, h', hâ‚€âŸ©
      use ğ“•_; use Î¼_; use p_; use k_; use h; use h'
      exact And.intro (le_trans hâ‚€.1 ord) hâ‚€.2
  }

  -- { carrier a :=
  --     âˆƒ (ğ“• : MeasurableSpace A) (Î¼' : PMF A) (p : I â†’ Permission Î±) (k : A â†’ PMF V),
  --       -- let
  --       let (P : IndexedPSpPm I Î± V) := Î» i â†¦
  --         {val := (sorry, sorry), property := sorry}
  --       P â‰¤ a âˆ§ âˆ€ i âˆˆ I, sorry
  -- , upper' := sorry
  -- }

  -- Â«existsÂ» (fun P : I â†’ ProbabilitySpace (Î± â†’ V) => sorry)
  -- âŸ¨setOf (fun a => âˆƒ P : I â†’ ProbabilitySpace (Î± â†’ V),
  --   âˆƒ p : I â†’ Permission Î±,
  --   âˆƒ h : âˆ€ i, (P i).compatiblePerm (p i),
  --   âˆƒ Îº : (i : I) â†’ Î² â†’ @Measure (Î± â†’ V) (P i).ÏƒAlg,
  --   (fun i => âŸ¨âŸ¨P i, p iâŸ©, h iâŸ© : IndexedPSpPm I Î± V) â‰¤ a âˆ§ âˆ€ i, (P i).Î¼ = Î¼.toMeasure.bind (Îº i) âˆ§
  --     âˆ€ v âˆˆ Î¼.support, K v (fun j => âŸ¨âŸ¨@ProbabilitySpace.mk _ (P j).ÏƒAlg (Îº j v) sorry, p jâŸ©, h jâŸ©)), by sorryâŸ©

notation "ğ‘ª_" => jointCondition

/-- The lifting of a relation `R : Set (s â†’ V)`, where `s : Set (I Ã— Î±)`, to a hyper-assertion -/
noncomputable def liftRelation [DecidableEq V] [MeasurableSpace V]
    (s : Set (I Ã— Î±)) (R : Set (s â†’ V)) : HyperAssertion I Î± V :=
  Â«existsÂ» (fun Î¼ : PMF (s â†’ V) =>
    sep (lift (âˆ‘' x : R, Î¼ x = 1))
      (ğ‘ª_ Î¼ (fun v : s â†’ V =>
        Â«forallÂ» (fun x : s => assertTrue x.1.1 (fun y => v x = y x.1.2)))))

/-- Weakest precondition of a program -/
def wp (t : IndexedPSpPm I Î± V â†’ IndexedPSpPm I Î± V) (Q : HyperAssertion I Î± V) : HyperAssertion I Î± V :=
  âŸ¨setOf (fun a => âˆ€ Î¼â‚€ c, (a * c) â‰¤ IndexedPSpPm.liftProb Î¼â‚€ â†’
    âˆƒ b, (b * c) â‰¤ t (IndexedPSpPm.liftProb Î¼â‚€) âˆ§ Q b), by sorryâŸ©

section ProgramLogic

/-! ### The program logic of Bluebell -/

-- TODO: we also need to state the regular rules of separation logic, so stuff like
theorem and_comm {P Q : HyperAssertion I Î± V} : P âˆ§ Q âŠ£âŠ¢ Q âˆ§ P := sorry

/-- If `P` and `Q` affect disjoint sets of indices, then `P âˆ§ Q` entails `P âˆ— Q` -/
theorem sep_of_and [DecidableEq I] [Fintype I] {P Q : HyperAssertion I Î± V}
    (h : relevantIndices P âˆ© relevantIndices Q = âˆ…) : (P âˆ§ Q) âŠ¢ iprop(P âˆ— Q) := by
  sorry

/-- If `EâŸ¨iâŸ©` is sampled from both `Î¼` and `Î¼'`, then `âŒœ Î¼ = Î¼' âŒ` holds as a proposition -/
theorem sampledFrom_inj {Î² : Type*} [MeasurableSpace Î²] {i : I} {E : (Î± â†’ V) â†’ Î²} {Î¼ Î¼' : PMF Î²} :
    (assertSampledFrom i E Î¼) âˆ§ (assertSampledFrom i E Î¼') âŠ¢ âŒœ Î¼ = Î¼' âŒ := by
  sorry

/-- `Eâ‚âŸ¨iâŸ©` and `Eâ‚‚âŸ¨iâŸ©` are both true if and only if `Eâ‚âŸ¨iâŸ© âˆ§ Eâ‚‚âŸ¨iâŸ©` is true -/
theorem sep_assertTrue_iff {i : I} {Eâ‚ Eâ‚‚ : (Î± â†’ V) â†’ Bool} :
    (assertTrue i Eâ‚) âˆ— (assertTrue i Eâ‚‚) âŠ£âŠ¢ assertTrue i (fun x => Eâ‚ x âˆ§ Eâ‚‚ x) := by
  sorry

/-- If `pabs(ğ‘ƒ, pvar(ğ¸âŸ¨ğ‘–âŸ©))` (need to define this), then `assertTrue i E âˆ§ P` entails `assertTrue i E âˆ— P` -/
theorem sep_of_and_assertTrue {i : I} {E : (Î± â†’ V) â†’ Bool} {P : HyperAssertion I Î± V}
    (h : True) : (assertTrue i E) âˆ— P âŠ¢ (assertTrue i E) âˆ§ P := by
  sorry

/-- Sampling hyper-assertions `(Eâ‚âŸ¨iâŸ©, Eâ‚‚âŸ¨iâŸ©) âˆ¼ (Î¼â‚, Î¼â‚‚)` for a product space can be split
  into sampling `Eâ‚âŸ¨iâŸ© âˆ¼ Î¼â‚` and `Eâ‚‚âŸ¨iâŸ© âˆ¼ Î¼â‚‚` -/
theorem sampledFrom_prod {Î²â‚ Î²â‚‚ : Type _} [MeasurableSpace Î²â‚] [MeasurableSpace Î²â‚‚] {i : I}
    (Eâ‚ : (Î± â†’ V) â†’ Î²â‚) (Eâ‚‚ : (Î± â†’ V) â†’ Î²â‚‚) (Î¼â‚ : PMF Î²â‚) (Î¼â‚‚ : PMF Î²â‚‚) :
      assertSampledFrom i (fun x => (Eâ‚ x, Eâ‚‚ x)) (Prod.mk <$> Î¼â‚ <*> Î¼â‚‚) âŠ¢
        (assertSampledFrom i Eâ‚ Î¼â‚) âˆ— (assertSampledFrom i Eâ‚‚ Î¼â‚‚) := by
  sorry

section JointConditioning

variable {Î² : Type*} [MeasurableSpace Î²] {Î¼ : PMF Î²} {K Kâ‚ Kâ‚‚ : Î² â†’ HyperAssertion I Î± V}
  [MeasurableSpace V]

theorem C_conseq (h : âˆ€ v, Kâ‚ v âŠ¢ Kâ‚‚ v) : ğ‘ª_ Î¼ Kâ‚ âŠ¢ ğ‘ª_ Î¼ Kâ‚‚ := by
  sorry

theorem C_frame {P : HyperAssertion I Î± V} : P âˆ— ğ‘ª_ Î¼ K âŠ¢ ğ‘ª_ Î¼ (fun v => sep P (K v)) := by
  sorry

theorem C_unit_left [Countable Î²] [MeasurableSingletonClass Î²] {vâ‚€ : Î²} :
    ğ‘ª_ (MeasureTheory.Measure.dirac vâ‚€).toPMF K âŠ£âŠ¢ K vâ‚€ := by
  sorry

theorem C_unit_right [DecidableEq Î²] {i : I} {E : (Î± â†’ V) â†’ Î²} {Î¼ : PMF Î²} :
    assertSampledFrom i E Î¼ âŠ£âŠ¢ ğ‘ª_ Î¼ (fun v => assertTrue i (fun x => E x = v)) := by
  sorry

theorem C_assoc {Î²â‚ Î²â‚‚ : Type _} [MeasurableSpace Î²â‚] [MeasurableSpace Î²â‚‚]
    {Î¼ : PMF Î²â‚} {Îº : Î²â‚ â†’ PMF Î²â‚‚} {K : Î²â‚ Ã— Î²â‚‚ â†’ HyperAssertion I Î± V} :
      ğ‘ª_ Î¼ (fun v => ğ‘ª_ (Îº v) (fun w => K (v, w))) âŠ¢
        ğ‘ª_ (do let v â† Î¼; let w â† Îº v; return (v, w)) K := by
  sorry

theorem C_unassoc {Î²â‚ Î²â‚‚ : Type _} [MeasurableSpace Î²â‚] [MeasurableSpace Î²â‚‚]
    {Î¼ : PMF Î²â‚} {Îº : Î²â‚ â†’ PMF Î²â‚‚} {K : Î²â‚‚ â†’ HyperAssertion I Î± V} :
      ğ‘ª_ (Î¼.bind Îº) (fun w => K w) âŠ¢ ğ‘ª_ Î¼ (fun v => ğ‘ª_ (Îº v) (fun w => K w)) := by
  sorry

theorem C_and [DecidableEq I] [Fintype I] (h : âˆ€ v, relevantIndices (Kâ‚ v) âˆ© relevantIndices (Kâ‚‚ v) = âˆ…) :
    ğ‘ª_ Î¼ Kâ‚ âˆ§ ğ‘ª_ Î¼ Kâ‚‚ âŠ¢ ğ‘ª_ Î¼ (fun v => and (Kâ‚ v) (Kâ‚‚ v)) := by
  sorry

/-- Also requires that the measurable space on `Î²` is the top one -/
theorem C_exists {Î³ : Type*} {Q : Î² Ã— Î³ â†’ HyperAssertion I Î± V} :
    ğ‘ª_ Î¼ (fun v => âˆƒ x, Q (v, x)) âŠ¢ âˆƒ f : Î² â†’ Î³, ğ‘ª_ Î¼ (fun v => Q (v, f v)) := by
  sorry

theorem C_forall {Î³ : Type*} {Q : Î² Ã— Î³ â†’ HyperAssertion I Î± V} :
    ğ‘ª_ Î¼ (fun v => Â«forallÂ» (fun x => Q (v, x))) âŠ¢ âˆ€ x, ğ‘ª_ Î¼ (fun v => Q (v, x)) := by
  sorry

theorem C_transfer {Î²' : Type*} [MeasurableSpace Î²'] {Î¼' : PMF Î²'} (f : Î¼'.support â‰ƒ Î¼.support)
    (h : âˆ€ b, (hb : b âˆˆ Î¼'.support) â†’ Î¼' b = Î¼ (f âŸ¨b, hbâŸ©).1) :
      ğ‘ª_ Î¼ K âŠ¢ ğ‘ª_ Î¼' (fun b => K (f âŸ¨b, sorryâŸ©)) := by
  sorry

theorem C_sep_assertTrue {i : I} {E : (Î± â†’ V) â†’ Bool} :
    ğ‘ª_ Î¼ (fun v => sep (K v) (assertTrue i E)) âŠ¢ assertTrue i E âˆ— ğ‘ª_ Î¼ K := by
  sorry

theorem C_pure {s : Set Î²} :
    âŒœ âˆ‘' x : s, Î¼ x = 1 âŒ âˆ— ğ‘ª_ Î¼ K âŠ£âŠ¢ ğ‘ª_ Î¼ (fun v => sep (pure (v âˆˆ s)) (K v)) := by
  sorry

end JointConditioning

section WeakestPrecondition

variable {I Î± V : Type*} [MeasurableSpace V] {t tâ‚ tâ‚‚ : IndexedPSpPm I Î± V â†’ IndexedPSpPm I Î± V}
  {P Q Q' Qâ‚ Qâ‚‚ : HyperAssertion I Î± V}

theorem wp_conseq (h : Q âŠ¢ Q') : (wp t Q) âŠ¢ (wp t Q') := by sorry

theorem wp_frame : P âˆ— (wp t Q) âŠ¢ (wp t (sep P Q)) := by sorry

theorem wp_comp : (wp tâ‚ (wp tâ‚‚ Q)) âŠ£âŠ¢ (wp (tâ‚ âˆ˜ tâ‚‚) Q) := by sorry

-- TODO: need to express `|t|`, the set of relevant indices of a program `t`, and `tâ‚ + tâ‚‚`, the
-- combined execution of `tâ‚` and `tâ‚‚` if they affect disjoint sets of indices (so we must model `t`
-- as an AST which is then interpreted into a function)
-- Required conditions: `(h1 : relevantIndices Qâ‚ âˆ© |tâ‚‚| âŠ† |tâ‚|) (h2 : relevantIndices Qâ‚‚ âˆ© |tâ‚| âŠ† |tâ‚‚|)`
theorem wp_conj : (wp tâ‚ Qâ‚) âˆ§ (wp tâ‚‚ Qâ‚‚) âŠ£âŠ¢ (wp (sorry) (and Qâ‚ Qâ‚‚)) := by sorry

-- TODO: what is `own_Î±` exactly (`own_ğ•` in the paper)?
theorem C_wp_swap {Î² : Type*} [MeasurableSpace Î²] {Î¼ : PMF Î²} {K : Î² â†’ HyperAssertion I Î± V} :
    ğ‘ª_ Î¼ (fun v => wp t (K v)) âˆ§ sorry âŠ¢ wp t (ğ‘ª_ Î¼ K) := by sorry

-- Add wp rules for the program syntax

end WeakestPrecondition

end ProgramLogic

end HyperAssertion
