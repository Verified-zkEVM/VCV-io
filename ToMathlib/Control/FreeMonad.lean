
/-
Copyright (c) 2024 Devon Tuma. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Devon Tuma
-/
import Mathlib.Data.Finset.Card
import Mathlib.Control.Lawful
import Mathlib.Probability.ProbabilityMassFunction.Monad
import Mathlib.Data.Fintype.Card
import ToMathlib.Control.MonadAlgebra

/-!
# Free Monad of a Functor
-/

universe u v w

section MonadHom

-- TODO: could consider trying to use this for more things instead
structure MonadHom (m : Type u → Type v) [Pure m] [Bind m]
    (n : Type u → Type w) [Pure n] [Bind n] where
  toFun {α : Type u} : m α → n α
  toFun_pure' {α : Type u} (x : α) : toFun (pure x) = (pure x : n α)
  toFun_bind' {α β : Type u} (x : m α) (y : α → m β) :
    toFun (x >>= y) = toFun x >>= toFun ∘ y

variable (m : Type u → Type v) [Monad m] (n : Type u → Type w) [Monad n]

infixr:25 " →ᵐ " => MonadHom

end MonadHom

/-- The free monad on a functor `f` is the type freely generated by values of type `f α`
and the operations `pure` and `bind`. Implemented directly rather than as a quotient.
Slightly different than constructions of free monads in Haskell because of universe issues. -/
inductive FreeMonad (f : Type u → Type v) (α : Type w) : Type (max (u + 1) v w)
  | protected pure (x : α) : FreeMonad f α
  | roll {β : Type u} (x : f β) (r : β → FreeMonad f α) : FreeMonad f α

namespace FreeMonad

variable {f : Type u → Type v} {α β γ : Type u}

/-- Lift an element of the base functor to the free monad by directly returning the result. -/
@[always_inline, inline]
def lift (x : f α) : FreeMonad f α := FreeMonad.roll x FreeMonad.pure

instance : MonadLift f (FreeMonad f) where
  monadLift x := FreeMonad.lift x

@[simp]
lemma monadLift_eq_lift (x : f α) :
  (x : FreeMonad f α) = FreeMonad.lift x := rfl

instance [Inhabited (f α)] : Inhabited (FreeMonad f α) := ⟨FreeMonad.lift default⟩

/-- Bind operator on `OracleComp spec` operation used in the monad definition. -/
@[always_inline, inline]
protected def bind : FreeMonad f α → (α → FreeMonad f β) → FreeMonad f β
  | FreeMonad.pure x, g => g x
  | FreeMonad.roll x r, g => FreeMonad.roll x (λ u ↦ FreeMonad.bind (r u) g)

@[simp]
lemma bind_pure (x : α) (r : α → FreeMonad f β) :
    FreeMonad.bind (FreeMonad.pure x) r = r x := rfl

@[simp]
lemma bind_roll (x : f α) (r : α → FreeMonad f β) (g : β → FreeMonad f γ) :
    FreeMonad.bind (FreeMonad.roll x r) g = FreeMonad.roll x (λ u ↦ FreeMonad.bind (r u) g) := rfl

@[simp]
lemma bind_lift (x : f α) (r : α → FreeMonad f β) :
    FreeMonad.bind (FreeMonad.lift x) r = FreeMonad.roll x r := rfl

instance : Monad (FreeMonad f) where
  pure := FreeMonad.pure
  bind := FreeMonad.bind

@[simp]
lemma monad_pure_def (x : α) : (pure x : FreeMonad f α) = FreeMonad.pure x := rfl

@[simp]
lemma monad_bind_def (x : FreeMonad f α) (g : α → FreeMonad f β) :
    x >>= g = FreeMonad.bind x g := rfl

instance : LawfulMonad (FreeMonad f) :=
  LawfulMonad.mk' (FreeMonad f)
    (λ x ↦ by
      induction' x with α x g r hr
      · rfl
      · exact congr_arg (FreeMonad.roll g) (funext λ u ↦ hr u))
    (λ x f ↦ rfl)
    (λ x f g ↦ by
      induction' x with α x g r hr
      · rfl
      · exact congr_arg (FreeMonad.roll g) (funext λ u ↦ hr u))

instance : MonadFunctor f (FreeMonad f) where
  monadMap g
    | FreeMonad.pure x => FreeMonad.pure x
    | FreeMonad.roll x r => g x >>= r

/-- Proving something about `FreeMonad f α` only requires two cases:
* `pure x` for some `x : α`
Note that we can't use `Sort v` instead of `Prop` due to universe levels.-/
@[elab_as_elim]
protected def inductionOn {C : FreeMonad f α → Prop}
    (pure : ∀ x, C (pure x))
    (roll : ∀ {β} (x : f β), (r : β → FreeMonad f α) →
      (∀ y, C (r y)) → C (x >>= r)) :
    (oa : FreeMonad f α) → C oa
  | FreeMonad.pure x => pure x
  | FreeMonad.roll x r => roll x _ (λ u ↦
      FreeMonad.inductionOn pure roll (r u))

section construct

universe z

/-- Shoulde be possible to unify with the above-/
@[elab_as_elim]
protected def construct {C : FreeMonad f α → Type z}
    (pure : (x : α) → C (pure x))
    (roll : {β : Type u} → (x : f β) → (r : β → FreeMonad f α) →
      ((y : β) → C (r y)) → C (x >>= r)) :
    (oa : FreeMonad f α) → C oa
  | .pure x => pure x
  | .roll x r => roll x _ (λ u ↦ FreeMonad.construct pure roll (r u))

variable {C : FreeMonad f α → Type z} (h_pure : (x : α) → C (pure x))
  (h_roll : {β : Type u} → (x : f β) → (r : β → FreeMonad f α) →
    ((y : β) → C (r y)) → C (x >>= r))

@[simp]
lemma construct_pure (y : α) : FreeMonad.construct h_pure h_roll (pure y) = h_pure y := rfl

@[simp]
lemma construct_roll (x : f β) (r : β → FreeMonad f α) :
    (FreeMonad.construct h_pure h_roll (roll x r) : C (roll x r)) =
      (h_roll x r (λ u ↦ FreeMonad.construct h_pure h_roll (r u))) := rfl

end construct

section mapM

universe z

variable {m : Type u → Type w} (s : {α : Type u} → f α → m α)

-- protected def mapM_aux [Pure m] [Bind m] (s : {α : Type u} → f α → m α) :
--     (oa : FreeMonad f α) → m α
--   | .pure x => pure x
--   | .roll x r => s x >>= λ u ↦ (r u).mapM_aux s

-- protected def mapM' [Monad m] [LawfulMonad m]
--     (s : {α : Type u} → f α → m α) : FreeMonad f →ᵐ m where
--   toFun := FreeMonad.mapM_aux s
--   toFun_pure' x := rfl
--   toFun_bind' x y := by
--     induction x using FreeMonad.inductionOn with
--     | pure x => simp [FreeMonad.mapM_aux]
--     | roll x r h => simp at h; simp [FreeMonad.mapM_aux, h]

/-- Canonical mapping of a free monad into any other monad, given a map on the base functor, -/
protected def mapM [Pure m] [Bind m] (s : {α : Type u} → f α → m α) :
    (oa : FreeMonad f α) → m α
  | .pure x => pure x
  | .roll x r => s x >>= λ u ↦ (r u).mapM s

variable [Monad m]

@[simp]
lemma mapM_pure (x : α) : (FreeMonad.pure x : FreeMonad f α).mapM s = pure x := rfl

@[simp]
lemma mapM_roll (x : f α) (r : α → FreeMonad f β) :
    (FreeMonad.roll x r).mapM s = s x >>= λ u ↦ (r u).mapM s := rfl

end mapM

end FreeMonad

section LawfulFailure

-- Stripped down version of `Alternative` to avoid diamonds.
class Failure (m : Type u → Type v) where
  fail {α : Type u} : m α

instance {m : Type u → Type v} [h : Alternative m] : Failure m where
  fail := h.failure

lemma failure_eq_fail (m : Type u → Type v) [Alternative m] (α : Type u) :
    (failure : m α) = Failure.fail := rfl

class LawfulFailure (m : Type u → Type v) [h' : Failure m] [h : Monad m] where
  failure_bind' {α β : Type u} (g : α → m β) : Failure.fail >>= g = Failure.fail
  map_failure' {α β : Type u} (g : α → β) : g <$> (Failure.fail : m α) = Failure.fail
  failure_seq' {α β : Type u} (ob : m α) : (Failure.fail : m (α → β)) <*> ob = Failure.fail

section fail

variable {m : Type u → Type v} [h' : Failure m] [h : Monad m]
   [hm : LawfulFailure m] {α β : Type u}

@[simp] lemma fail_bind (g : α → m β) : (Failure.fail : m α) >>= g = Failure.fail :=
  LawfulFailure.failure_bind' g

@[simp] lemma map_fail (g : α → β) : g <$> (Failure.fail : m α) = Failure.fail :=
  LawfulFailure.map_failure' g

@[simp] lemma fail_seq (ob : m α) : (Failure.fail : m (α → β)) <*> ob = Failure.fail :=
  LawfulFailure.failure_seq' ob

end fail

section failure

variable {m : Type u → Type v} [h' : Alternative m] [h : Monad m]
   [hm : LawfulFailure m] {α β : Type u}

@[simp] lemma failure_bind (g : α → m β) :
    (failure : m α) >>= g = failure :=
  by simp [failure_eq_fail]

@[simp] lemma map_failure (g : α → β) :
    h.toApplicative.map g (failure : m α) = failure :=
  by simp [failure_eq_fail]

@[simp] lemma failure_seq (ob : m α) :
    h.toApplicative.toSeq.seq (failure : m (α → β)) (λ _ ↦ ob) = failure :=
  by simp [failure_eq_fail]

end failure

-- @[simp] lemma pure_eq_pure (x : α) :
--     h'.toApplicative.toPure.pure x = h.toApplicative.toPure.pure x := by
--   simp only [hm.toApplicative_eq]

-- @[simp] lemma seq_eq_seq (x : m (α → β)) (y : m α) :
--     h'.toApplicative.toSeq.seq x (fun _ => y) =
--       h.toApplicative.toSeq.seq x (fun _ => y) := by
--   simp only [hm.toApplicative_eq]

-- @[simp] lemma map_eq_map (x : m α) (f : α → β) :
--     h'.toApplicative.toFunctor.map f x =
--       h.toApplicative.toFunctor.map f x := by
--   simp only [hm.toApplicative_eq]

end LawfulFailure

section PMF

variable {α β : Type u}

@[simp]
lemma PMF.monad_pure_eq_pure (x : α) : (Pure.pure x : PMF α) = PMF.pure x := rfl

@[simp]
lemma PMF.monad_bind_eq_bind (p : PMF α) (q : α → PMF β) :
    p >>= q = p.bind q := rfl

end PMF

namespace Option

instance : LawfulFailure Option where
  failure_bind' _ := rfl
  map_failure' _ := rfl
  failure_seq' _ := rfl

end Option

namespace OptionT

variable {m : Type u → Type v}
  {n : Type u → Type w}
  (f : {α : Type u} →  m α → n α) {α β γ : Type u}

-- @[simp]
lemma monad_pure_eq_pure [Monad m] (x : α) :
    (pure x : OptionT m α) = OptionT.pure x := rfl

-- @[simp]
lemma monad_bind_eq_bind [Monad m] (x : OptionT m α) (y : α → OptionT m β) :
    x >>= y = OptionT.bind x y := rfl

section mapM

/-- Canonical lifting of a map from `m α → n α` to one from `OptionT m α → n α`
given an `Alternative n` instance to handle failure. -/
protected def mapM {m : Type u → Type v} {n : Type u → Type w}
    [Failure n] [Monad n] (f : {α : Type u} → m α → n α)
    {α : Type u} (x : OptionT m α) : n α :=
  do match (← f x.run) with | some x => return x | none => Failure.fail

lemma mapM_pure [Monad m] [Monad n] [LawfulMonad n] [Failure n] [LawfulFailure n]
    (h : ∀ {α} (x : α), f (OptionT.pure x).run = pure x) (x : α) :
    OptionT.mapM f (pure x : OptionT m α) = pure x := by
  simp [OptionT.mapM, h, OptionT.monad_pure_eq_pure]

end mapM

lemma run_seq {α β : Type u} {m : Type u → Type v} [Monad m] [LawfulMonad m]
    (f : OptionT m (α → β)) (x : OptionT m α) :
    (f <*> x).run = (do let g ← f.run; match g with
      | some g => Option.map g <$> x.run
      | none => pure none) := by
  simp only [seq_eq_bind_map, run_bind, run_map]
  exact bind_congr fun | some x => rfl | none => rfl

@[simp]
lemma run_fail {α : Type u} {m : Type u → Type v} [Monad m] :
    (Failure.fail : OptionT m α).run = pure none := rfl

@[simp]
lemma run_failure {α : Type u} {m : Type u → Type v} [Monad m] :
    (failure : OptionT m α).run = pure none := rfl

instance (m : Type u → Type v) [Monad m] [LawfulMonad m] : LawfulFailure (OptionT m) where
  failure_bind' g := OptionT.ext (by simp)
  map_failure' g := OptionT.ext (by simp [map_eq_bind_pure_comp])
  failure_seq' ob := OptionT.ext (by simp [run_seq])
  -- toApplicative_eq := rfl

lemma liftM_def {m : Type u → Type v} [Monad m] {α : Type u}
    (x : m α) : (x : OptionT m α) = OptionT.lift x := rfl

end OptionT

namespace StateT

variable {m : Type u → Type v} {m' : Type u → Type w}
  {σ α β : Type u}

instance [MonadLift m m'] : MonadLift (StateT σ m) (StateT σ m') where
  monadLift x := StateT.mk fun s => liftM ((x.run) s)

@[simp]
lemma liftM_of_liftM_eq [MonadLift m m'] (x : StateT σ m α) :
    (liftM x : StateT σ m' α) = StateT.mk fun s => liftM (x.run s) := rfl

lemma liftM_def [Monad m] (x : m α) : (x : StateT σ m α) = StateT.lift x := rfl

-- TODO: should this be simp?
lemma monad_pure_def [Monad m] (x : α) :
    (pure x : StateT σ m α) = StateT.pure x := rfl

lemma monad_failure_def [Monad m] [Alternative m] :
    (failure : StateT σ m α) = StateT.failure := rfl

@[simp]
lemma run_failure [Monad m] [Alternative m] (s : σ) :
    (StateT.failure : StateT σ m α).run s = failure := rfl

@[simp]
lemma mk_eq_pure [Monad m] (x : α) :
  StateT.mk (λ s ↦ pure (x, s)) = (pure x : StateT σ m α) := rfl

@[simp]
lemma lift_failure [Alternative m] [Monad m] [LawfulFailure m] :
    (StateT.lift (failure : m α) : StateT σ m α) = failure :=
  StateT.ext fun x => by simp [StateT.failure, monad_failure_def]

end StateT

lemma list_mapM_loop_eq {m : Type u → Type v} [Monad m] [LawfulMonad m]
    {α β : Type u} (xs : List α) (f : α → m β) (ys : List β) :
    List.mapM.loop f xs ys = (ys.reverse ++ ·) <$> List.mapM.loop f xs [] := by
  revert ys
  induction xs with
  | nil => simp [List.mapM.loop]
  | cons x xs h =>
      intro ys
      simp only [List.mapM.loop, map_bind]
      refine congr_arg (f x >>= ·) (funext λ x ↦ ?_)
      simp [h (x :: ys), h [x]]

namespace FreeMonad

-- instance instMonadAlgebra {f} {pre : {α : Type v} → f α → α} : MonadAlgebra (FreeMonad f) where
--   monadAlg
--   | FreeMonad.pure x => x
--   | FreeMonad.roll x r => @instMonadAlgebra.monadAlg _ (r (pre x))

-- def prePostFree {f} {α β} (pre : α → Prop) (post : α × β → Prop) : FreeMonad f Prop → Prop
--   | FreeMonad.pure x => x
--   | FreeMonad.roll x r => ∃ inp, pre inp ∧ ∀ out, post (inp, out) → prePostFree pre post (r out)

end FreeMonad
