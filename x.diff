diff --git a/ToMathlib/ProbabilityTheory/Bluebell.lean b/ToMathlib/ProbabilityTheory/Bluebell.lean
index 8d31e27..d0e589d 100644
--- a/ToMathlib/ProbabilityTheory/Bluebell.lean
+++ b/ToMathlib/ProbabilityTheory/Bluebell.lean
@@ -4,13 +4,22 @@ import ToMathlib.ProbabilityTheory.Coupling
 import ToMathlib.ProbabilityTheory.IndepProduct
 
 /-! # Formalizing the Bluebell paper -/
+/-
+  Given a set of possible outcomes Œ© (sample space),
+    - An event space is a œÉ-algebra ùìï ‚àà ùî∏(Œ©), represented as `ùìï : MeasurableSpace Œ©`;
+    - A probability distribution Œº : ùìï ‚Üí [0, 1] ‚àà ùîª(ùìï), is represented as
+      `Œº : Measure Œ©` or a probability mass functions `Œº : PMF Œ©`
+      (see `MeasureTheory.Measure.toPMF` and `PMF.toMeasure`);
+      Note: Œº(a) abbreviates Œº({a})
+-/
 
 open Iris ProbabilityTheory MeasureTheory
 
 -- Indexed tuples
 def indexedTuple (Œ± : Type*) (I : Finset ‚Ñï) := I ‚Üí Œ±
 
-def indexedTuple.remove (Œ± : Type*) (I : Finset ‚Ñï) (J : Finset ‚Ñï) (h : J ‚äÜ I) :
+-- Question (Andrei): `(h : J ‚äÜ I)` not needed?
+def indexedTuple.remove (Œ± : Type*) (I : Finset ‚Ñï) (J : Finset ‚Ñï) /-(h : J ‚äÜ I)-/ :
     indexedTuple Œ± I ‚Üí indexedTuple Œ± (I \ J) :=
   fun x i => x ‚ü®i.1, by aesop‚ü©
 
@@ -28,6 +37,36 @@ instance {Œ± : Type*} [Valid Œ±] (p : Œ± ‚Üí Prop) : Valid (Subtype p) where
 instance {Œ± Œ≤ : Type*} [Valid Œ±] [Valid Œ≤] : Valid (Œ± √ó Œ≤) where
   valid := fun x => Valid.valid x.1 ‚àß Valid.valid x.2
 
+
+/--
+  The product of two measurable spaces on `Œ©` and `Œ©` is the measurable space
+  generated by
+-/
+def MeasurableSpace.prod' {Œ© : Type*}
+  (m‚ÇÅ : MeasurableSpace Œ©) (m‚ÇÇ : MeasurableSpace Œ©) : MeasurableSpace (Œ© √ó Œ©) :=
+  let seed : Set (Set (Œ© √ó Œ©)) := do
+    let X‚ÇÅ : Set Œ© ‚Üê MeasurableSet[m‚ÇÅ]
+    let X‚ÇÇ : Set Œ© ‚Üê MeasurableSet[m‚ÇÇ]
+    return (X‚ÇÅ.prod X‚ÇÇ : Set (Œ© √ó Œ©))
+  MeasurableSpace.generateFrom seed
+
+def MeasurableSpace.prod'' {Œ©‚ÇÅ Œ©‚ÇÇ}
+  (m‚ÇÅ : MeasurableSpace Œ©‚ÇÅ) (m‚ÇÇ : MeasurableSpace Œ©‚ÇÇ) : MeasurableSpace (Œ©‚ÇÅ √ó Œ©‚ÇÇ) :=
+  let seed : Set (Set (Œ©‚ÇÅ √ó Œ©‚ÇÇ)) := do
+    let X‚ÇÅ : Set Œ©‚ÇÅ ‚Üê MeasurableSet[m‚ÇÅ]
+    let X‚ÇÇ : Set Œ©‚ÇÇ ‚Üê MeasurableSet[m‚ÇÇ]
+    return X‚ÇÅ.prod X‚ÇÇ
+  MeasurableSpace.generateFrom seed
+
+lemma prod_eq_prod' {Œ©} {m‚ÇÅ m‚ÇÇ : MeasurableSpace Œ©} :
+  MeasurableSpace.prod m‚ÇÅ m‚ÇÇ = MeasurableSpace.prod' m‚ÇÅ m‚ÇÇ
+:= by
+  unfold MeasurableSpace.prod MeasurableSpace.prod'
+  -- simp
+  unfold_projs
+  simp
+  sorry
+
 /-- The class of **discrete** cameras, which do not care about step-indexing -/
 class DiscreteCMRA (Œ± : Type*) extends CommSemigroup Œ±, Valid Œ± where
   equiv : Œ± ‚Üí Œ± ‚Üí Prop
@@ -51,7 +90,8 @@ section DiscreteCMRA
 variable {Œ± : Type*} [DiscreteCMRA Œ±] {x y‚ÇÅ y‚ÇÇ : Œ±}
 open DiscreteCMRA
 
-lemma valid_extend : valid x ‚Üí equiv x (y‚ÇÅ * y‚ÇÇ) ‚Üí ‚àÉ z‚ÇÅ z‚ÇÇ, equiv x (z‚ÇÅ * z‚ÇÇ) := by tauto
+-- Question (Andrei): This lemma doesn't need the hypothesys `valid x`; and is not needed itself
+lemma valid_extend : /- valid x ‚Üí -/ equiv x (y‚ÇÅ * y‚ÇÇ) ‚Üí ‚àÉ z‚ÇÅ z‚ÇÇ, equiv x (z‚ÇÅ * z‚ÇÇ) := by tauto
 
 lemma valid_l_of_equiv_mul (h‚ÇÅ : valid x) (h‚ÇÇ : equiv x (y‚ÇÅ * y‚ÇÇ)) : valid y‚ÇÅ :=
                            valid_mul (valid_equiv h‚ÇÇ h‚ÇÅ)
@@ -59,9 +99,12 @@ lemma valid_l_of_equiv_mul (h‚ÇÅ : valid x) (h‚ÇÇ : equiv x (y‚ÇÅ * y‚ÇÇ)) : val
 lemma valid_r_of_equiv_mul (h‚ÇÅ : valid x) (h‚ÇÇ : equiv x (y‚ÇÅ * y‚ÇÇ)) : valid y‚ÇÇ :=
                            valid_mul (valid_equiv (mul_comm y‚ÇÅ y‚ÇÇ ‚ñ∏ h‚ÇÇ) h‚ÇÅ)
 
+-- Question (Andrei): `valid_extend` not needed here?
 example : valid x ‚Üí equiv x (y‚ÇÅ * y‚ÇÇ) ‚Üí ‚àÉ z‚ÇÅ z‚ÇÇ, equiv x (z‚ÇÅ * z‚ÇÇ) ‚àß valid z‚ÇÅ ‚àß valid z‚ÇÇ :=
-  Œª h‚ÇÅ h‚ÇÇ ‚Ü¶ let ‚ü®z‚ÇÅ, z‚ÇÇ, h‚ü© := valid_extend h‚ÇÅ h‚ÇÇ
-            ‚ü®z‚ÇÅ, z‚ÇÇ, h, valid_l_of_equiv_mul h‚ÇÅ h, valid_r_of_equiv_mul h‚ÇÅ h‚ü©
+  Œª h‚ÇÅ h‚ÇÇ ‚Ü¶ ‚ü®y‚ÇÅ, y‚ÇÇ, h‚ÇÇ, valid_l_of_equiv_mul h‚ÇÅ h‚ÇÇ, valid_r_of_equiv_mul h‚ÇÅ h‚ÇÇ‚ü©
+
+  -- Œª h‚ÇÅ h‚ÇÇ ‚Ü¶ let ‚ü®z‚ÇÅ, z‚ÇÇ, h‚ü© := valid_extend /- h‚ÇÅ -/ h‚ÇÇ
+  --           ‚ü®z‚ÇÅ, z‚ÇÇ, h, valid_l_of_equiv_mul h‚ÇÅ h, valid_r_of_equiv_mul h‚ÇÅ h‚ü©
 
 end DiscreteCMRA
 
@@ -74,7 +117,7 @@ instance DiscreteCMRA.instOFE (Œ± : Type*) [DiscreteCMRA Œ±] : OFE Œ± where
 
 /-- A discrete CMRA can be converted to a regular CMRA -/
 instance DiscreteCMRA.instCMRA {Œ± : Type*} [DiscreteCMRA Œ±] : CMRA Œ± :=
-  { 
+  {
     pcore := pcore
     op := (¬∑*¬∑)
     validN := fun _ x ‚Ü¶ valid x
@@ -165,7 +208,8 @@ variable {Œ± : Type*}
 -- instance : MulOneClass (Permission Œ±) := inferInstanceAs (MulOneClass (Multiplicative (Œ± ‚Üí ‚Ñö‚â•0)))
 -- instance : MulLeftMono (Permission Œ±) := inferInstanceAs (MulLeftMono (Multiplicative (Œ± ‚Üí ‚Ñö‚â•0)))
 
-/-- Permissions form an `OrderedUnitalResourceAlgebra` where `‚â§` is defined pointwise, a resource is valid iff it's below `1` pointwise, and composition is pointwise multiplication -/
+/-- Permissions form an `OrderedUnitalResourceAlgebra` where `‚â§` is defined pointwise,
+  a resource is valid iff it's below `1` pointwise, and composition is pointwise multiplication -/
 instance : OrderedUnitalResourceAlgebra (Permission Œ±) where
   valid := fun p => p ‚â§ 1
   valid_one := by simp
@@ -214,6 +258,8 @@ variable {V : Type*}
 
 - the trivial probability space on the zero part of the permission `ùüô_ ({a // p a = 0} ‚Üí V)`
 - another probability space `P'` on the non-zero part of the permission -/
+-- Wrong
+-- We need product and union spaces
 def ProbabilityTheory.ProbabilitySpace.compatiblePerm (_P : ProbabilitySpace (Œ± ‚Üí V)) (p : Permission Œ±) : Prop :=
   ‚àÉ _P' : ProbabilitySpace ({a // p a > 0} ‚Üí V), True
 
@@ -235,6 +281,7 @@ namespace PSpPm
 
 /-- Lift a probability space to a probability space-permission pair, via coupling it with the
   all-one permission -/
+-- TODO (Andrei): In the Bluebell paper, Œº is used for distribution, while ùìü is used for probability spaces
 def liftProb (Œº : ProbabilitySpace (Œ± ‚Üí V)) : PSpPm Œ± V :=
   ‚ü®‚ü®Œº, 1‚ü©, by sorry‚ü©
 
@@ -248,6 +295,7 @@ instance [Nonempty V] : Mul (PSpPm Œ± V) where
   -- TODO: need to prove product preserves compatibility
   mul Pp‚ÇÅ Pp‚ÇÇ := ‚ü®‚ü®Pp‚ÇÅ.1.1 * Pp‚ÇÇ.1.1, Pp‚ÇÅ.1.2 * Pp‚ÇÇ.1.2‚ü©, by sorry‚ü©
 
+-- TODO (Andrei): We need validity defined
 -- instance : Valid (PSpPm Œ± V) := inferInstanceAs <|
 --   Valid (Subtype (fun Pp : PSp (Œ± ‚Üí V) √ó Permission Œ± => Pp.1.compatiblePerm Pp.2))
 
@@ -263,7 +311,9 @@ end PSpPm
 
 end
 
-/-- The main model of Bluebell is a function type `I ‚Üí PSpPm Œ± V`, where `I` is the index set of (independent) program executions. The resource algebra structure is lifted pointwise from `PSpPm`.
+/-- The main model of Bluebell is a function type `I ‚Üí PSpPm Œ± V`, where `I` is
+  the index set of (independent) program executions. The resource algebra structure
+  is lifted pointwise from `PSpPm`.
 
 To handle multiple programs drawn from index set `I`, we use the RA `I ‚Üí PSpPm` where
 operations are lifted pointwise -/
@@ -460,8 +510,41 @@ def isPermissionAbstract (X : Set (I √ó Œ±)) (P : HyperAssertion I Œ± V) : Prop
   -- ‚àÄ Pp : IndexedPSpPm I Œ± V, ‚àÄ q : ‚Ñö‚â•0, ‚àÄ n : ‚Ñï+, P Pp ‚â§ P ‚Üí ‚àÉ Pp' : IndexedPSpPm I Œ± V, Pp' ‚â§ P ‚àß Pp = Pp' ‚àß True
 
 /-- The joint conditioning modality -/
-def jointCondition {Œ≤ : Type*} [MeasurableSpace Œ≤] [MeasurableSpace V] (Œº : PMF Œ≤) (K : Œ≤ ‚Üí HyperAssertion I Œ± V) :
-    HyperAssertion I Œ± V := sorry
+
+def jointCondition {A : Type*} /- [MeasurableSpace V] -/
+  (Œº : PMF A)
+  (K : A ‚Üí HyperAssertion I Œ± V) :
+  HyperAssertion I Œ± V
+:=
+  -- TODO (Andrei): define Perm ‚âú I ‚Üí Permission Œ±
+  { carrier a :=
+      ‚àÉ (ùìï_ : I ‚Üí MeasurableSpace (Œ± ‚Üí V))
+        (Œº_ : I ‚Üí PMF (Œ± ‚Üí V))
+        (p_ : I ‚Üí Permission Œ±)
+        (k_ : I ‚Üí A ‚Üí PMF (Œ± ‚Üí V)),
+        -- (ùìï_, Œº_, p_)
+        let P‚ÇÅ : IndexedPSpPm I Œ± V := Œª i ‚Ü¶
+          let _ : MeasurableSpace (Œ± ‚Üí V) := ùìï_ i
+          let ps‚ÇÅ : PSp (Œ± ‚Üí V) := some (ProbabilitySpace.ofPMF (Œº_ i))
+          {val := (ps‚ÇÅ, p_ i), property := sorry}
+        -- (ùìï_, k_ (I)(œÖ), p_)
+        let P‚ÇÇ œÖ : IndexedPSpPm I Œ± V := Œª i ‚Ü¶
+          let _ : MeasurableSpace (Œ± ‚Üí V) := ùìï_ i
+          let ps‚ÇÇ : PSp (Œ± ‚Üí V) := some (ProbabilitySpace.ofPMF (k_ i œÖ))
+          {val := (ps‚ÇÇ, p_ i), property := sorry}
+        P‚ÇÅ ‚â§ a ‚àß ‚àÄ i : I, Œº_ i = Œº.bind (k_ i) ‚àß ‚àÄ œÖ ‚àà Œº.support, K œÖ (P‚ÇÇ œÖ)
+  , upper' := sorry
+  }
+
+  -- { carrier a :=
+  --     ‚àÉ (ùìï : MeasurableSpace A) (Œº' : PMF A) (p : I ‚Üí Permission Œ±) (k : A ‚Üí PMF V),
+  --       -- let
+  --       let (P : IndexedPSpPm I Œ± V) := Œª i ‚Ü¶
+  --         {val := (sorry, sorry), property := sorry}
+  --       P ‚â§ a ‚àß ‚àÄ i ‚àà I, sorry
+  -- , upper' := sorry
+  -- }
+
   -- ¬´exists¬ª (fun P : I ‚Üí ProbabilitySpace (Œ± ‚Üí V) => sorry)
   -- ‚ü®setOf (fun a => ‚àÉ P : I ‚Üí ProbabilitySpace (Œ± ‚Üí V),
   --   ‚àÉ p : I ‚Üí Permission Œ±,
